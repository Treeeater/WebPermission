/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include "config.h"
#include "V8WebGLRenderingContext.h"

#if ENABLE(WEBGL)

#include "ExceptionCode.h"
#include "RuntimeEnabledFeatures.h"
#include "V8ArrayBuffer.h"
#include "V8ArrayBufferView.h"
#include "V8Binding.h"
#include "V8BindingMacros.h"
#include "V8BindingState.h"
#include "V8CanvasRenderingContext.h"
#include "V8DOMWrapper.h"
#include "V8HTMLCanvasElement.h"
#include "V8HTMLImageElement.h"
#include "V8HTMLVideoElement.h"
#include "V8ImageData.h"
#include "V8IsolatedContext.h"
#include "V8Proxy.h"
#include "V8WebGLActiveInfo.h"
#include "V8WebGLBuffer.h"
#include "V8WebGLContextAttributes.h"
#include "V8WebGLFramebuffer.h"
#include "V8WebGLProgram.h"
#include "V8WebGLRenderbuffer.h"
#include "V8WebGLShader.h"
#include "V8WebGLTexture.h"
#include "V8WebGLUniformLocation.h"
#include <wtf/GetPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>

namespace WebCore {

WrapperTypeInfo V8WebGLRenderingContext::info = { V8WebGLRenderingContext::GetTemplate, V8WebGLRenderingContext::derefObject, 0, &V8CanvasRenderingContext::info };

namespace WebGLRenderingContextInternal {

template <typename T> void V8_USE(T) { }

static v8::Handle<v8::Value> drawingBufferWidthAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WebGLRenderingContext.drawingBufferWidth._get");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(info.Holder());
    return v8::Integer::New(imp->drawingBufferWidth());
}

static v8::Handle<v8::Value> drawingBufferHeightAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WebGLRenderingContext.drawingBufferHeight._get");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(info.Holder());
    return v8::Integer::New(imp->drawingBufferHeight());
}

static v8::Handle<v8::Value> activeTextureCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.activeTexture");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, texture, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->activeTexture(texture, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> attachShaderCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.attachShader");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLShader::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    imp->attachShader(program, shader, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bindAttribLocationCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bindAttribLocation");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined));
    imp->bindAttribLocation(program, index, name, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bindBufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bindBuffer");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLBuffer::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLBuffer*, buffer, V8WebGLBuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8WebGLBuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    imp->bindBuffer(target, buffer, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bindFramebufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bindFramebuffer");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLFramebuffer::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLFramebuffer*, framebuffer, V8WebGLFramebuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8WebGLFramebuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    imp->bindFramebuffer(target, framebuffer, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bindRenderbufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bindRenderbuffer");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLRenderbuffer::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLRenderbuffer*, renderbuffer, V8WebGLRenderbuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8WebGLRenderbuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    imp->bindRenderbuffer(target, renderbuffer, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bindTextureCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bindTexture");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLTexture::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLTexture*, texture, V8WebGLTexture::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8WebGLTexture::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    imp->bindTexture(target, texture, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> blendColorCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.blendColor");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, red, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, green, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, blue, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, alpha, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->NumberValue()));
    imp->blendColor(red, green, blue, alpha);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> blendEquationCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.blendEquation");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, mode, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->blendEquation(mode);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> blendEquationSeparateCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.blendEquationSeparate");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, modeRGB, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, modeAlpha, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    imp->blendEquationSeparate(modeRGB, modeAlpha);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> blendFuncCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.blendFunc");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, sfactor, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, dfactor, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    imp->blendFunc(sfactor, dfactor);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> blendFuncSeparateCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.blendFuncSeparate");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, srcRGB, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, dstRGB, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, srcAlpha, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, dstAlpha, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bufferData1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferData1");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8ArrayBuffer::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBuffer*, data, V8ArrayBuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8ArrayBuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(unsigned, usage, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->bufferData(target, data, usage, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bufferData2Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferData2");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8ArrayBufferView::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBufferView*, data, V8ArrayBufferView::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8ArrayBufferView::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(unsigned, usage, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->bufferData(target, data, usage, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bufferData3Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferData3");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, size, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, usage, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->bufferData(target, size, usage, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bufferDataCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferData");
    if ((args.Length() == 3 && (args[1]->IsNull() || V8ArrayBuffer::HasInstance(args[1]))))
        return bufferData1Callback(args);
    if ((args.Length() == 3 && (args[1]->IsNull() || V8ArrayBufferView::HasInstance(args[1]))))
        return bufferData2Callback(args);
    if (args.Length() == 3)
        return bufferData3Callback(args);
    V8Proxy::throwTypeError();
    return notHandledByInterceptor();
}

static v8::Handle<v8::Value> bufferSubData1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferSubData1");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, offset, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    if (args.Length() > 2 && !isUndefinedOrNull(args[2]) && !V8ArrayBuffer::HasInstance(args[2])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBuffer*, data, V8ArrayBuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)) ? V8ArrayBuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined))) : 0);
    imp->bufferSubData(target, offset, data, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bufferSubData2Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferSubData2");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, offset, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    if (args.Length() > 2 && !isUndefinedOrNull(args[2]) && !V8ArrayBufferView::HasInstance(args[2])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBufferView*, data, V8ArrayBufferView::HasInstance(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)) ? V8ArrayBufferView::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined))) : 0);
    imp->bufferSubData(target, offset, data, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> bufferSubDataCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.bufferSubData");
    if ((args.Length() == 3 && (args[2]->IsNull() || V8ArrayBuffer::HasInstance(args[2]))))
        return bufferSubData1Callback(args);
    if ((args.Length() == 3 && (args[2]->IsNull() || V8ArrayBufferView::HasInstance(args[2]))))
        return bufferSubData2Callback(args);
    V8Proxy::throwTypeError();
    return notHandledByInterceptor();
}

static v8::Handle<v8::Value> checkFramebufferStatusCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.checkFramebufferStatus");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    return v8::Integer::NewFromUnsigned(imp->checkFramebufferStatus(target));
}

static v8::Handle<v8::Value> clearCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.clear");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, mask, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->clear(mask);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearColorCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.clearColor");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, red, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, green, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, blue, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, alpha, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->NumberValue()));
    imp->clearColor(red, green, blue, alpha);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearDepthCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.clearDepth");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, depth, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    imp->clearDepth(depth);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearStencilCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.clearStencil");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, s, toInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->clearStencil(s);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> colorMaskCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.colorMask");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(bool, red, MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->BooleanValue());
    EXCEPTION_BLOCK(bool, green, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->BooleanValue());
    EXCEPTION_BLOCK(bool, blue, MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->BooleanValue());
    EXCEPTION_BLOCK(bool, alpha, MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->BooleanValue());
    imp->colorMask(red, green, blue, alpha);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> compileShaderCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.compileShader");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->compileShader(shader, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> copyTexImage2DCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.copyTexImage2D");
    if (args.Length() < 8)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, border, toInt32(MAYBE_MISSING_PARAMETER(args, 7, MissingIsUndefined)));
    imp->copyTexImage2D(target, level, internalformat, x, y, width, height, border);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> copyTexSubImage2DCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.copyTexSubImage2D");
    if (args.Length() < 8)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, xoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, yoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 7, MissingIsUndefined)));
    imp->copyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> createBufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.createBuffer");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return toV8(imp->createBuffer());
}

static v8::Handle<v8::Value> createFramebufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.createFramebuffer");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return toV8(imp->createFramebuffer());
}

static v8::Handle<v8::Value> createProgramCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.createProgram");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return toV8(imp->createProgram());
}

static v8::Handle<v8::Value> createRenderbufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.createRenderbuffer");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return toV8(imp->createRenderbuffer());
}

static v8::Handle<v8::Value> createShaderCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.createShader");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    RefPtr<WebGLShader> result = imp->createShader(type, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> createTextureCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.createTexture");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return toV8(imp->createTexture());
}

static v8::Handle<v8::Value> cullFaceCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.cullFace");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, mode, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->cullFace(mode);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> deleteBufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.deleteBuffer");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLBuffer::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLBuffer*, buffer, V8WebGLBuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLBuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->deleteBuffer(buffer);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> deleteFramebufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.deleteFramebuffer");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLFramebuffer::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLFramebuffer*, framebuffer, V8WebGLFramebuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLFramebuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->deleteFramebuffer(framebuffer);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> deleteProgramCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.deleteProgram");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->deleteProgram(program);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> deleteRenderbufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.deleteRenderbuffer");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLRenderbuffer::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLRenderbuffer*, renderbuffer, V8WebGLRenderbuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLRenderbuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->deleteRenderbuffer(renderbuffer);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> deleteShaderCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.deleteShader");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->deleteShader(shader);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> deleteTextureCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.deleteTexture");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLTexture::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLTexture*, texture, V8WebGLTexture::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLTexture::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->deleteTexture(texture);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> depthFuncCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.depthFunc");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, func, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->depthFunc(func);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> depthMaskCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.depthMask");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(bool, flag, MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->BooleanValue());
    imp->depthMask(flag);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> depthRangeCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.depthRange");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, zNear, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, zFar, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    imp->depthRange(zNear, zFar);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> detachShaderCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.detachShader");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    if (args.Length() > 1 && !isUndefinedOrNull(args[1]) && !V8WebGLShader::HasInstance(args[1])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined))) : 0);
    imp->detachShader(program, shader, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> disableCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.disable");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, cap, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->disable(cap);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> disableVertexAttribArrayCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.disableVertexAttribArray");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->disableVertexAttribArray(index, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> drawArraysCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.drawArrays");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, mode, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, first, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, count, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->drawArrays(mode, first, count, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> drawElementsCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.drawElements");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, mode, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, count, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, offset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->drawElements(mode, count, type, offset, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> enableCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.enable");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, cap, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->enable(cap);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> enableVertexAttribArrayCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.enableVertexAttribArray");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->enableVertexAttribArray(index, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> finishCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.finish");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    imp->finish();
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> flushCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.flush");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    imp->flush();
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> framebufferRenderbufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.framebufferRenderbuffer");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, attachment, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, renderbuffertarget, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    if (args.Length() > 3 && !isUndefinedOrNull(args[3]) && !V8WebGLRenderbuffer::HasInstance(args[3])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLRenderbuffer*, renderbuffer, V8WebGLRenderbuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)) ? V8WebGLRenderbuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined))) : 0);
    imp->framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> framebufferTexture2DCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.framebufferTexture2D");
    if (args.Length() < 5)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, attachment, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, textarget, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    if (args.Length() > 3 && !isUndefinedOrNull(args[3]) && !V8WebGLTexture::HasInstance(args[3])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLTexture*, texture, V8WebGLTexture::HasInstance(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)) ? V8WebGLTexture::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    imp->framebufferTexture2D(target, attachment, textarget, texture, level, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> frontFaceCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.frontFace");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, mode, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->frontFace(mode);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> generateMipmapCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.generateMipmap");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->generateMipmap(target);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getActiveAttribCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getActiveAttrib");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    RefPtr<WebGLActiveInfo> result = imp->getActiveAttrib(program, index, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getActiveUniformCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getActiveUniform");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    RefPtr<WebGLActiveInfo> result = imp->getActiveUniform(program, index, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getAttribLocationCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getAttribLocation");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined));
    return v8::Integer::New(imp->getAttribLocation(program, name));
}

static v8::Handle<v8::Value> getContextAttributesCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getContextAttributes");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return toV8(imp->getContextAttributes());
}

static v8::Handle<v8::Value> getErrorCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getError");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return v8::Integer::NewFromUnsigned(imp->getError());
}

static v8::Handle<v8::Value> getProgramInfoLogCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getProgramInfoLog");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    String result = imp->getProgramInfoLog(program, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8StringOrNull(result);
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getShaderInfoLogCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getShaderInfoLog");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    String result = imp->getShaderInfoLog(shader, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8StringOrNull(result);
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getShaderSourceCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getShaderSource");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    String result = imp->getShaderSource(shader, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8StringOrNull(result);
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getUniformLocationCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getUniformLocation");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined));
    RefPtr<WebGLUniformLocation> result = imp->getUniformLocation(program, name, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> getVertexAttribOffsetCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.getVertexAttribOffset");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, index, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, pname, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    return v8::Integer::New(imp->getVertexAttribOffset(index, pname));
}

static v8::Handle<v8::Value> hintCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.hint");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, mode, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    imp->hint(target, mode);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> isBufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isBuffer");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLBuffer::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLBuffer*, buffer, V8WebGLBuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLBuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    return v8Boolean(imp->isBuffer(buffer));
}

static v8::Handle<v8::Value> isContextLostCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isContextLost");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    return v8Boolean(imp->isContextLost());
}

static v8::Handle<v8::Value> isEnabledCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isEnabled");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, cap, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    return v8Boolean(imp->isEnabled(cap));
}

static v8::Handle<v8::Value> isFramebufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isFramebuffer");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLFramebuffer::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLFramebuffer*, framebuffer, V8WebGLFramebuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLFramebuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    return v8Boolean(imp->isFramebuffer(framebuffer));
}

static v8::Handle<v8::Value> isProgramCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isProgram");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    return v8Boolean(imp->isProgram(program));
}

static v8::Handle<v8::Value> isRenderbufferCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isRenderbuffer");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLRenderbuffer::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLRenderbuffer*, renderbuffer, V8WebGLRenderbuffer::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLRenderbuffer::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    return v8Boolean(imp->isRenderbuffer(renderbuffer));
}

static v8::Handle<v8::Value> isShaderCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isShader");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    return v8Boolean(imp->isShader(shader));
}

static v8::Handle<v8::Value> isTextureCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.isTexture");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLTexture::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLTexture*, texture, V8WebGLTexture::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLTexture::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    return v8Boolean(imp->isTexture(texture));
}

static v8::Handle<v8::Value> lineWidthCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.lineWidth");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, width, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    imp->lineWidth(width);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> linkProgramCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.linkProgram");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->linkProgram(program, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> pixelStoreiCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.pixelStorei");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, pname, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, param, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    imp->pixelStorei(pname, param);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> polygonOffsetCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.polygonOffset");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, factor, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, units, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    imp->polygonOffset(factor, units);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> readPixelsCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.readPixels");
    if (args.Length() < 7)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    if (args.Length() > 6 && !isUndefinedOrNull(args[6]) && !V8ArrayBufferView::HasInstance(args[6])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBufferView*, pixels, V8ArrayBufferView::HasInstance(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)) ? V8ArrayBufferView::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined))) : 0);
    imp->readPixels(x, y, width, height, format, type, pixels, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> releaseShaderCompilerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.releaseShaderCompiler");
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    imp->releaseShaderCompiler();
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> renderbufferStorageCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.renderbufferStorage");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->renderbufferStorage(target, internalformat, width, height);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> sampleCoverageCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.sampleCoverage");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(float, value, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(bool, invert, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->BooleanValue());
    imp->sampleCoverage(value, invert);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> scissorCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.scissor");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->scissor(x, y, width, height);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> shaderSourceCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.shaderSource");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLShader::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLShader*, shader, V8WebGLShader::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLShader::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, string, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined));
    imp->shaderSource(shader, string, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> stencilFuncCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.stencilFunc");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, func, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, ref, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, mask, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->stencilFunc(func, ref, mask);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> stencilFuncSeparateCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.stencilFuncSeparate");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, face, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, func, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, ref, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, mask, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->stencilFuncSeparate(face, func, ref, mask);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> stencilMaskCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.stencilMask");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, mask, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->stencilMask(mask);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> stencilMaskSeparateCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.stencilMaskSeparate");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, face, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, mask, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    imp->stencilMaskSeparate(face, mask);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> stencilOpCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.stencilOp");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, fail, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, zfail, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, zpass, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->stencilOp(fail, zfail, zpass);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> stencilOpSeparateCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.stencilOpSeparate");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, face, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, fail, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, zfail, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, zpass, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->stencilOpSeparate(face, fail, zfail, zpass);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texParameterfCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texParameterf");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, pname, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(float, param, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    imp->texParameterf(target, pname, param);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texParameteriCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texParameteri");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, pname, toUInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, param, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->texParameteri(target, pname, param);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texImage2D1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texImage2D1");
    if (args.Length() < 9)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, border, toInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 7, MissingIsUndefined)));
    if (args.Length() > 8 && !isUndefinedOrNull(args[8]) && !V8ArrayBufferView::HasInstance(args[8])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBufferView*, pixels, V8ArrayBufferView::HasInstance(MAYBE_MISSING_PARAMETER(args, 8, MissingIsUndefined)) ? V8ArrayBufferView::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 8, MissingIsUndefined))) : 0);
    imp->texImage2D(target, level, internalformat, width, height, border, format, type, pixels, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texImage2D2Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texImage2D2");
    if (args.Length() < 6)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    if (args.Length() > 5 && !isUndefinedOrNull(args[5]) && !V8ImageData::HasInstance(args[5])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ImageData*, pixels, V8ImageData::HasInstance(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)) ? V8ImageData::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined))) : 0);
    imp->texImage2D(target, level, internalformat, format, type, pixels, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texImage2D3Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texImage2D3");
    if (args.Length() < 6)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    if (args.Length() > 5 && !isUndefinedOrNull(args[5]) && !V8HTMLImageElement::HasInstance(args[5])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(HTMLImageElement*, image, V8HTMLImageElement::HasInstance(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)) ? V8HTMLImageElement::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined))) : 0);
    imp->texImage2D(target, level, internalformat, format, type, image, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texImage2D4Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texImage2D4");
    if (args.Length() < 6)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    if (args.Length() > 5 && !isUndefinedOrNull(args[5]) && !V8HTMLCanvasElement::HasInstance(args[5])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(HTMLCanvasElement*, canvas, V8HTMLCanvasElement::HasInstance(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)) ? V8HTMLCanvasElement::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined))) : 0);
    imp->texImage2D(target, level, internalformat, format, type, canvas, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texImage2D5Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texImage2D5");
    if (args.Length() < 6)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, internalformat, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    if (args.Length() > 5 && !isUndefinedOrNull(args[5]) && !V8HTMLVideoElement::HasInstance(args[5])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(HTMLVideoElement*, video, V8HTMLVideoElement::HasInstance(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)) ? V8HTMLVideoElement::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined))) : 0);
    imp->texImage2D(target, level, internalformat, format, type, video, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texImage2DCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texImage2D");
    if ((args.Length() == 9 && (args[8]->IsNull() || V8ArrayBufferView::HasInstance(args[8]))))
        return texImage2D1Callback(args);
    if ((args.Length() == 6 && (args[5]->IsNull() || V8ImageData::HasInstance(args[5]))))
        return texImage2D2Callback(args);
    if ((args.Length() == 6 && (args[5]->IsNull() || V8HTMLImageElement::HasInstance(args[5]))))
        return texImage2D3Callback(args);
    if ((args.Length() == 6 && (args[5]->IsNull() || V8HTMLCanvasElement::HasInstance(args[5]))))
        return texImage2D4Callback(args);
    if ((args.Length() == 6 && (args[5]->IsNull() || V8HTMLVideoElement::HasInstance(args[5]))))
        return texImage2D5Callback(args);
    V8Proxy::throwTypeError();
    return notHandledByInterceptor();
}

static v8::Handle<v8::Value> texSubImage2D1Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texSubImage2D1");
    if (args.Length() < 9)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, xoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, yoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 7, MissingIsUndefined)));
    if (args.Length() > 8 && !isUndefinedOrNull(args[8]) && !V8ArrayBufferView::HasInstance(args[8])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ArrayBufferView*, pixels, V8ArrayBufferView::HasInstance(MAYBE_MISSING_PARAMETER(args, 8, MissingIsUndefined)) ? V8ArrayBufferView::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 8, MissingIsUndefined))) : 0);
    imp->texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texSubImage2D2Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texSubImage2D2");
    if (args.Length() < 7)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, xoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, yoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    if (args.Length() > 6 && !isUndefinedOrNull(args[6]) && !V8ImageData::HasInstance(args[6])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(ImageData*, pixels, V8ImageData::HasInstance(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)) ? V8ImageData::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined))) : 0);
    imp->texSubImage2D(target, level, xoffset, yoffset, format, type, pixels, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texSubImage2D3Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texSubImage2D3");
    if (args.Length() < 7)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, xoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, yoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    if (args.Length() > 6 && !isUndefinedOrNull(args[6]) && !V8HTMLImageElement::HasInstance(args[6])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(HTMLImageElement*, image, V8HTMLImageElement::HasInstance(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)) ? V8HTMLImageElement::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined))) : 0);
    imp->texSubImage2D(target, level, xoffset, yoffset, format, type, image, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texSubImage2D4Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texSubImage2D4");
    if (args.Length() < 7)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, xoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, yoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    if (args.Length() > 6 && !isUndefinedOrNull(args[6]) && !V8HTMLCanvasElement::HasInstance(args[6])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(HTMLCanvasElement*, canvas, V8HTMLCanvasElement::HasInstance(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)) ? V8HTMLCanvasElement::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined))) : 0);
    imp->texSubImage2D(target, level, xoffset, yoffset, format, type, canvas, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texSubImage2D5Callback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texSubImage2D5");
    if (args.Length() < 7)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, target, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, level, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, xoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, yoffset, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, format, toUInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    if (args.Length() > 6 && !isUndefinedOrNull(args[6]) && !V8HTMLVideoElement::HasInstance(args[6])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(HTMLVideoElement*, video, V8HTMLVideoElement::HasInstance(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined)) ? V8HTMLVideoElement::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 6, MissingIsUndefined))) : 0);
    imp->texSubImage2D(target, level, xoffset, yoffset, format, type, video, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> texSubImage2DCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.texSubImage2D");
    if ((args.Length() == 9 && (args[8]->IsNull() || V8ArrayBufferView::HasInstance(args[8]))))
        return texSubImage2D1Callback(args);
    if ((args.Length() == 7 && (args[6]->IsNull() || V8ImageData::HasInstance(args[6]))))
        return texSubImage2D2Callback(args);
    if ((args.Length() == 7 && (args[6]->IsNull() || V8HTMLImageElement::HasInstance(args[6]))))
        return texSubImage2D3Callback(args);
    if ((args.Length() == 7 && (args[6]->IsNull() || V8HTMLCanvasElement::HasInstance(args[6]))))
        return texSubImage2D4Callback(args);
    if ((args.Length() == 7 && (args[6]->IsNull() || V8HTMLVideoElement::HasInstance(args[6]))))
        return texSubImage2D5Callback(args);
    V8Proxy::throwTypeError();
    return notHandledByInterceptor();
}

static v8::Handle<v8::Value> uniform1fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform1f");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    imp->uniform1f(location, x, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform1iCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform1i");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    imp->uniform1i(location, x, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform2fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform2f");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, y, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    imp->uniform2f(location, x, y, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform2iCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform2i");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    imp->uniform2i(location, x, y, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform3fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform3f");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, y, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, z, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->NumberValue()));
    imp->uniform3f(location, x, y, z, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform3iCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform3i");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, z, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->uniform3i(location, x, y, z, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform4fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform4f");
    if (args.Length() < 5)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, y, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, z, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, w, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)->NumberValue()));
    imp->uniform4f(location, x, y, z, w, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> uniform4iCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.uniform4i");
    if (args.Length() < 5)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLUniformLocation::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLUniformLocation*, location, V8WebGLUniformLocation::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLUniformLocation::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, z, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, w, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    imp->uniform4i(location, x, y, z, w, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> useProgramCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.useProgram");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->useProgram(program, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> validateProgramCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.validateProgram");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    EXCEPTION_BLOCK(WebGLProgram*, program, V8WebGLProgram::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    imp->validateProgram(program, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> vertexAttrib1fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib1f");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, indx, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    imp->vertexAttrib1f(indx, x);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> vertexAttrib2fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib2f");
    if (args.Length() < 3)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, indx, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, y, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    imp->vertexAttrib2f(indx, x, y);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> vertexAttrib3fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib3f");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, indx, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, y, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, z, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->NumberValue()));
    imp->vertexAttrib3f(indx, x, y, z);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> vertexAttrib4fCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttrib4f");
    if (args.Length() < 5)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(unsigned, indx, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(float, x, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, y, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, z, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->NumberValue()));
    EXCEPTION_BLOCK(float, w, static_cast<float>(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)->NumberValue()));
    imp->vertexAttrib4f(indx, x, y, z, w);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> vertexAttribPointerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.vertexAttribPointer");
    if (args.Length() < 6)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(unsigned, indx, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, size, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(unsigned, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(bool, normalized, MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)->BooleanValue());
    EXCEPTION_BLOCK(int, stride, toInt32(MAYBE_MISSING_PARAMETER(args, 4, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, offset, toInt32(MAYBE_MISSING_PARAMETER(args, 5, MissingIsUndefined)));
    imp->vertexAttribPointer(indx, size, type, normalized, stride, offset, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8::Handle<v8::Value>();
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> viewportCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WebGLRenderingContext.viewport");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WebGLRenderingContext* imp = V8WebGLRenderingContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, x, toInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, y, toInt32(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, width, toInt32(MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined)));
    EXCEPTION_BLOCK(int, height, toInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    imp->viewport(x, y, width, height);
    return v8::Handle<v8::Value>();
}

} // namespace WebGLRenderingContextInternal

static const BatchedAttribute WebGLRenderingContextAttrs[] = {
    // Attribute 'drawingBufferWidth' (Type: 'readonly attribute' ExtAttr: '')
    {"drawingBufferWidth", WebGLRenderingContextInternal::drawingBufferWidthAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    // Attribute 'drawingBufferHeight' (Type: 'readonly attribute' ExtAttr: '')
    {"drawingBufferHeight", WebGLRenderingContextInternal::drawingBufferHeightAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
};

static const BatchedCallback WebGLRenderingContextCallbacks[] = {
    {"activeTexture", WebGLRenderingContextInternal::activeTextureCallback},
    {"attachShader", WebGLRenderingContextInternal::attachShaderCallback},
    {"bindAttribLocation", WebGLRenderingContextInternal::bindAttribLocationCallback},
    {"bindBuffer", WebGLRenderingContextInternal::bindBufferCallback},
    {"bindFramebuffer", WebGLRenderingContextInternal::bindFramebufferCallback},
    {"bindRenderbuffer", WebGLRenderingContextInternal::bindRenderbufferCallback},
    {"bindTexture", WebGLRenderingContextInternal::bindTextureCallback},
    {"blendColor", WebGLRenderingContextInternal::blendColorCallback},
    {"blendEquation", WebGLRenderingContextInternal::blendEquationCallback},
    {"blendEquationSeparate", WebGLRenderingContextInternal::blendEquationSeparateCallback},
    {"blendFunc", WebGLRenderingContextInternal::blendFuncCallback},
    {"blendFuncSeparate", WebGLRenderingContextInternal::blendFuncSeparateCallback},
    {"bufferData", WebGLRenderingContextInternal::bufferDataCallback},
    {"bufferSubData", WebGLRenderingContextInternal::bufferSubDataCallback},
    {"checkFramebufferStatus", WebGLRenderingContextInternal::checkFramebufferStatusCallback},
    {"clear", WebGLRenderingContextInternal::clearCallback},
    {"clearColor", WebGLRenderingContextInternal::clearColorCallback},
    {"clearDepth", WebGLRenderingContextInternal::clearDepthCallback},
    {"clearStencil", WebGLRenderingContextInternal::clearStencilCallback},
    {"colorMask", WebGLRenderingContextInternal::colorMaskCallback},
    {"compileShader", WebGLRenderingContextInternal::compileShaderCallback},
    {"copyTexImage2D", WebGLRenderingContextInternal::copyTexImage2DCallback},
    {"copyTexSubImage2D", WebGLRenderingContextInternal::copyTexSubImage2DCallback},
    {"createBuffer", WebGLRenderingContextInternal::createBufferCallback},
    {"createFramebuffer", WebGLRenderingContextInternal::createFramebufferCallback},
    {"createProgram", WebGLRenderingContextInternal::createProgramCallback},
    {"createRenderbuffer", WebGLRenderingContextInternal::createRenderbufferCallback},
    {"createShader", WebGLRenderingContextInternal::createShaderCallback},
    {"createTexture", WebGLRenderingContextInternal::createTextureCallback},
    {"cullFace", WebGLRenderingContextInternal::cullFaceCallback},
    {"deleteBuffer", WebGLRenderingContextInternal::deleteBufferCallback},
    {"deleteFramebuffer", WebGLRenderingContextInternal::deleteFramebufferCallback},
    {"deleteProgram", WebGLRenderingContextInternal::deleteProgramCallback},
    {"deleteRenderbuffer", WebGLRenderingContextInternal::deleteRenderbufferCallback},
    {"deleteShader", WebGLRenderingContextInternal::deleteShaderCallback},
    {"deleteTexture", WebGLRenderingContextInternal::deleteTextureCallback},
    {"depthFunc", WebGLRenderingContextInternal::depthFuncCallback},
    {"depthMask", WebGLRenderingContextInternal::depthMaskCallback},
    {"depthRange", WebGLRenderingContextInternal::depthRangeCallback},
    {"detachShader", WebGLRenderingContextInternal::detachShaderCallback},
    {"disable", WebGLRenderingContextInternal::disableCallback},
    {"disableVertexAttribArray", WebGLRenderingContextInternal::disableVertexAttribArrayCallback},
    {"drawArrays", WebGLRenderingContextInternal::drawArraysCallback},
    {"drawElements", WebGLRenderingContextInternal::drawElementsCallback},
    {"enable", WebGLRenderingContextInternal::enableCallback},
    {"enableVertexAttribArray", WebGLRenderingContextInternal::enableVertexAttribArrayCallback},
    {"finish", WebGLRenderingContextInternal::finishCallback},
    {"flush", WebGLRenderingContextInternal::flushCallback},
    {"framebufferRenderbuffer", WebGLRenderingContextInternal::framebufferRenderbufferCallback},
    {"framebufferTexture2D", WebGLRenderingContextInternal::framebufferTexture2DCallback},
    {"frontFace", WebGLRenderingContextInternal::frontFaceCallback},
    {"generateMipmap", WebGLRenderingContextInternal::generateMipmapCallback},
    {"getActiveAttrib", WebGLRenderingContextInternal::getActiveAttribCallback},
    {"getActiveUniform", WebGLRenderingContextInternal::getActiveUniformCallback},
    {"getAttachedShaders", V8WebGLRenderingContext::getAttachedShadersCallback},
    {"getAttribLocation", WebGLRenderingContextInternal::getAttribLocationCallback},
    {"getBufferParameter", V8WebGLRenderingContext::getBufferParameterCallback},
    {"getContextAttributes", WebGLRenderingContextInternal::getContextAttributesCallback},
    {"getError", WebGLRenderingContextInternal::getErrorCallback},
    {"getExtension", V8WebGLRenderingContext::getExtensionCallback},
    {"getFramebufferAttachmentParameter", V8WebGLRenderingContext::getFramebufferAttachmentParameterCallback},
    {"getParameter", V8WebGLRenderingContext::getParameterCallback},
    {"getProgramParameter", V8WebGLRenderingContext::getProgramParameterCallback},
    {"getProgramInfoLog", WebGLRenderingContextInternal::getProgramInfoLogCallback},
    {"getRenderbufferParameter", V8WebGLRenderingContext::getRenderbufferParameterCallback},
    {"getShaderParameter", V8WebGLRenderingContext::getShaderParameterCallback},
    {"getShaderInfoLog", WebGLRenderingContextInternal::getShaderInfoLogCallback},
    {"getShaderSource", WebGLRenderingContextInternal::getShaderSourceCallback},
    {"getSupportedExtensions", V8WebGLRenderingContext::getSupportedExtensionsCallback},
    {"getTexParameter", V8WebGLRenderingContext::getTexParameterCallback},
    {"getUniform", V8WebGLRenderingContext::getUniformCallback},
    {"getUniformLocation", WebGLRenderingContextInternal::getUniformLocationCallback},
    {"getVertexAttrib", V8WebGLRenderingContext::getVertexAttribCallback},
    {"getVertexAttribOffset", WebGLRenderingContextInternal::getVertexAttribOffsetCallback},
    {"hint", WebGLRenderingContextInternal::hintCallback},
    {"isBuffer", WebGLRenderingContextInternal::isBufferCallback},
    {"isContextLost", WebGLRenderingContextInternal::isContextLostCallback},
    {"isEnabled", WebGLRenderingContextInternal::isEnabledCallback},
    {"isFramebuffer", WebGLRenderingContextInternal::isFramebufferCallback},
    {"isProgram", WebGLRenderingContextInternal::isProgramCallback},
    {"isRenderbuffer", WebGLRenderingContextInternal::isRenderbufferCallback},
    {"isShader", WebGLRenderingContextInternal::isShaderCallback},
    {"isTexture", WebGLRenderingContextInternal::isTextureCallback},
    {"lineWidth", WebGLRenderingContextInternal::lineWidthCallback},
    {"linkProgram", WebGLRenderingContextInternal::linkProgramCallback},
    {"pixelStorei", WebGLRenderingContextInternal::pixelStoreiCallback},
    {"polygonOffset", WebGLRenderingContextInternal::polygonOffsetCallback},
    {"readPixels", WebGLRenderingContextInternal::readPixelsCallback},
    {"releaseShaderCompiler", WebGLRenderingContextInternal::releaseShaderCompilerCallback},
    {"renderbufferStorage", WebGLRenderingContextInternal::renderbufferStorageCallback},
    {"sampleCoverage", WebGLRenderingContextInternal::sampleCoverageCallback},
    {"scissor", WebGLRenderingContextInternal::scissorCallback},
    {"shaderSource", WebGLRenderingContextInternal::shaderSourceCallback},
    {"stencilFunc", WebGLRenderingContextInternal::stencilFuncCallback},
    {"stencilFuncSeparate", WebGLRenderingContextInternal::stencilFuncSeparateCallback},
    {"stencilMask", WebGLRenderingContextInternal::stencilMaskCallback},
    {"stencilMaskSeparate", WebGLRenderingContextInternal::stencilMaskSeparateCallback},
    {"stencilOp", WebGLRenderingContextInternal::stencilOpCallback},
    {"stencilOpSeparate", WebGLRenderingContextInternal::stencilOpSeparateCallback},
    {"texParameterf", WebGLRenderingContextInternal::texParameterfCallback},
    {"texParameteri", WebGLRenderingContextInternal::texParameteriCallback},
    {"texImage2D", WebGLRenderingContextInternal::texImage2DCallback},
    {"texSubImage2D", WebGLRenderingContextInternal::texSubImage2DCallback},
    {"uniform1f", WebGLRenderingContextInternal::uniform1fCallback},
    {"uniform1fv", V8WebGLRenderingContext::uniform1fvCallback},
    {"uniform1i", WebGLRenderingContextInternal::uniform1iCallback},
    {"uniform1iv", V8WebGLRenderingContext::uniform1ivCallback},
    {"uniform2f", WebGLRenderingContextInternal::uniform2fCallback},
    {"uniform2fv", V8WebGLRenderingContext::uniform2fvCallback},
    {"uniform2i", WebGLRenderingContextInternal::uniform2iCallback},
    {"uniform2iv", V8WebGLRenderingContext::uniform2ivCallback},
    {"uniform3f", WebGLRenderingContextInternal::uniform3fCallback},
    {"uniform3fv", V8WebGLRenderingContext::uniform3fvCallback},
    {"uniform3i", WebGLRenderingContextInternal::uniform3iCallback},
    {"uniform3iv", V8WebGLRenderingContext::uniform3ivCallback},
    {"uniform4f", WebGLRenderingContextInternal::uniform4fCallback},
    {"uniform4fv", V8WebGLRenderingContext::uniform4fvCallback},
    {"uniform4i", WebGLRenderingContextInternal::uniform4iCallback},
    {"uniform4iv", V8WebGLRenderingContext::uniform4ivCallback},
    {"uniformMatrix2fv", V8WebGLRenderingContext::uniformMatrix2fvCallback},
    {"uniformMatrix3fv", V8WebGLRenderingContext::uniformMatrix3fvCallback},
    {"uniformMatrix4fv", V8WebGLRenderingContext::uniformMatrix4fvCallback},
    {"useProgram", WebGLRenderingContextInternal::useProgramCallback},
    {"validateProgram", WebGLRenderingContextInternal::validateProgramCallback},
    {"vertexAttrib1f", WebGLRenderingContextInternal::vertexAttrib1fCallback},
    {"vertexAttrib1fv", V8WebGLRenderingContext::vertexAttrib1fvCallback},
    {"vertexAttrib2f", WebGLRenderingContextInternal::vertexAttrib2fCallback},
    {"vertexAttrib2fv", V8WebGLRenderingContext::vertexAttrib2fvCallback},
    {"vertexAttrib3f", WebGLRenderingContextInternal::vertexAttrib3fCallback},
    {"vertexAttrib3fv", V8WebGLRenderingContext::vertexAttrib3fvCallback},
    {"vertexAttrib4f", WebGLRenderingContextInternal::vertexAttrib4fCallback},
    {"vertexAttrib4fv", V8WebGLRenderingContext::vertexAttrib4fvCallback},
    {"vertexAttribPointer", WebGLRenderingContextInternal::vertexAttribPointerCallback},
    {"viewport", WebGLRenderingContextInternal::viewportCallback},
};

static const BatchedConstant WebGLRenderingContextConsts[] = {
    {"DEPTH_BUFFER_BIT", static_cast<signed int>(0x00000100)},
    {"STENCIL_BUFFER_BIT", static_cast<signed int>(0x00000400)},
    {"COLOR_BUFFER_BIT", static_cast<signed int>(0x00004000)},
    {"POINTS", static_cast<signed int>(0x0000)},
    {"LINES", static_cast<signed int>(0x0001)},
    {"LINE_LOOP", static_cast<signed int>(0x0002)},
    {"LINE_STRIP", static_cast<signed int>(0x0003)},
    {"TRIANGLES", static_cast<signed int>(0x0004)},
    {"TRIANGLE_STRIP", static_cast<signed int>(0x0005)},
    {"TRIANGLE_FAN", static_cast<signed int>(0x0006)},
    {"ZERO", static_cast<signed int>(0)},
    {"ONE", static_cast<signed int>(1)},
    {"SRC_COLOR", static_cast<signed int>(0x0300)},
    {"ONE_MINUS_SRC_COLOR", static_cast<signed int>(0x0301)},
    {"SRC_ALPHA", static_cast<signed int>(0x0302)},
    {"ONE_MINUS_SRC_ALPHA", static_cast<signed int>(0x0303)},
    {"DST_ALPHA", static_cast<signed int>(0x0304)},
    {"ONE_MINUS_DST_ALPHA", static_cast<signed int>(0x0305)},
    {"DST_COLOR", static_cast<signed int>(0x0306)},
    {"ONE_MINUS_DST_COLOR", static_cast<signed int>(0x0307)},
    {"SRC_ALPHA_SATURATE", static_cast<signed int>(0x0308)},
    {"FUNC_ADD", static_cast<signed int>(0x8006)},
    {"BLEND_EQUATION", static_cast<signed int>(0x8009)},
    {"BLEND_EQUATION_RGB", static_cast<signed int>(0x8009)},
    {"BLEND_EQUATION_ALPHA", static_cast<signed int>(0x883D)},
    {"FUNC_SUBTRACT", static_cast<signed int>(0x800A)},
    {"FUNC_REVERSE_SUBTRACT", static_cast<signed int>(0x800B)},
    {"BLEND_DST_RGB", static_cast<signed int>(0x80C8)},
    {"BLEND_SRC_RGB", static_cast<signed int>(0x80C9)},
    {"BLEND_DST_ALPHA", static_cast<signed int>(0x80CA)},
    {"BLEND_SRC_ALPHA", static_cast<signed int>(0x80CB)},
    {"CONSTANT_COLOR", static_cast<signed int>(0x8001)},
    {"ONE_MINUS_CONSTANT_COLOR", static_cast<signed int>(0x8002)},
    {"CONSTANT_ALPHA", static_cast<signed int>(0x8003)},
    {"ONE_MINUS_CONSTANT_ALPHA", static_cast<signed int>(0x8004)},
    {"BLEND_COLOR", static_cast<signed int>(0x8005)},
    {"ARRAY_BUFFER", static_cast<signed int>(0x8892)},
    {"ELEMENT_ARRAY_BUFFER", static_cast<signed int>(0x8893)},
    {"ARRAY_BUFFER_BINDING", static_cast<signed int>(0x8894)},
    {"ELEMENT_ARRAY_BUFFER_BINDING", static_cast<signed int>(0x8895)},
    {"STREAM_DRAW", static_cast<signed int>(0x88E0)},
    {"STATIC_DRAW", static_cast<signed int>(0x88E4)},
    {"DYNAMIC_DRAW", static_cast<signed int>(0x88E8)},
    {"BUFFER_SIZE", static_cast<signed int>(0x8764)},
    {"BUFFER_USAGE", static_cast<signed int>(0x8765)},
    {"CURRENT_VERTEX_ATTRIB", static_cast<signed int>(0x8626)},
    {"FRONT", static_cast<signed int>(0x0404)},
    {"BACK", static_cast<signed int>(0x0405)},
    {"FRONT_AND_BACK", static_cast<signed int>(0x0408)},
    {"TEXTURE_2D", static_cast<signed int>(0x0DE1)},
    {"CULL_FACE", static_cast<signed int>(0x0B44)},
    {"BLEND", static_cast<signed int>(0x0BE2)},
    {"DITHER", static_cast<signed int>(0x0BD0)},
    {"STENCIL_TEST", static_cast<signed int>(0x0B90)},
    {"DEPTH_TEST", static_cast<signed int>(0x0B71)},
    {"SCISSOR_TEST", static_cast<signed int>(0x0C11)},
    {"POLYGON_OFFSET_FILL", static_cast<signed int>(0x8037)},
    {"SAMPLE_ALPHA_TO_COVERAGE", static_cast<signed int>(0x809E)},
    {"SAMPLE_COVERAGE", static_cast<signed int>(0x80A0)},
    {"NO_ERROR", static_cast<signed int>(0)},
    {"INVALID_ENUM", static_cast<signed int>(0x0500)},
    {"INVALID_VALUE", static_cast<signed int>(0x0501)},
    {"INVALID_OPERATION", static_cast<signed int>(0x0502)},
    {"OUT_OF_MEMORY", static_cast<signed int>(0x0505)},
    {"CW", static_cast<signed int>(0x0900)},
    {"CCW", static_cast<signed int>(0x0901)},
    {"LINE_WIDTH", static_cast<signed int>(0x0B21)},
    {"ALIASED_POINT_SIZE_RANGE", static_cast<signed int>(0x846D)},
    {"ALIASED_LINE_WIDTH_RANGE", static_cast<signed int>(0x846E)},
    {"CULL_FACE_MODE", static_cast<signed int>(0x0B45)},
    {"FRONT_FACE", static_cast<signed int>(0x0B46)},
    {"DEPTH_RANGE", static_cast<signed int>(0x0B70)},
    {"DEPTH_WRITEMASK", static_cast<signed int>(0x0B72)},
    {"DEPTH_CLEAR_VALUE", static_cast<signed int>(0x0B73)},
    {"DEPTH_FUNC", static_cast<signed int>(0x0B74)},
    {"STENCIL_CLEAR_VALUE", static_cast<signed int>(0x0B91)},
    {"STENCIL_FUNC", static_cast<signed int>(0x0B92)},
    {"STENCIL_FAIL", static_cast<signed int>(0x0B94)},
    {"STENCIL_PASS_DEPTH_FAIL", static_cast<signed int>(0x0B95)},
    {"STENCIL_PASS_DEPTH_PASS", static_cast<signed int>(0x0B96)},
    {"STENCIL_REF", static_cast<signed int>(0x0B97)},
    {"STENCIL_VALUE_MASK", static_cast<signed int>(0x0B93)},
    {"STENCIL_WRITEMASK", static_cast<signed int>(0x0B98)},
    {"STENCIL_BACK_FUNC", static_cast<signed int>(0x8800)},
    {"STENCIL_BACK_FAIL", static_cast<signed int>(0x8801)},
    {"STENCIL_BACK_PASS_DEPTH_FAIL", static_cast<signed int>(0x8802)},
    {"STENCIL_BACK_PASS_DEPTH_PASS", static_cast<signed int>(0x8803)},
    {"STENCIL_BACK_REF", static_cast<signed int>(0x8CA3)},
    {"STENCIL_BACK_VALUE_MASK", static_cast<signed int>(0x8CA4)},
    {"STENCIL_BACK_WRITEMASK", static_cast<signed int>(0x8CA5)},
    {"VIEWPORT", static_cast<signed int>(0x0BA2)},
    {"SCISSOR_BOX", static_cast<signed int>(0x0C10)},
    {"COLOR_CLEAR_VALUE", static_cast<signed int>(0x0C22)},
    {"COLOR_WRITEMASK", static_cast<signed int>(0x0C23)},
    {"UNPACK_ALIGNMENT", static_cast<signed int>(0x0CF5)},
    {"PACK_ALIGNMENT", static_cast<signed int>(0x0D05)},
    {"MAX_TEXTURE_SIZE", static_cast<signed int>(0x0D33)},
    {"MAX_VIEWPORT_DIMS", static_cast<signed int>(0x0D3A)},
    {"SUBPIXEL_BITS", static_cast<signed int>(0x0D50)},
    {"RED_BITS", static_cast<signed int>(0x0D52)},
    {"GREEN_BITS", static_cast<signed int>(0x0D53)},
    {"BLUE_BITS", static_cast<signed int>(0x0D54)},
    {"ALPHA_BITS", static_cast<signed int>(0x0D55)},
    {"DEPTH_BITS", static_cast<signed int>(0x0D56)},
    {"STENCIL_BITS", static_cast<signed int>(0x0D57)},
    {"POLYGON_OFFSET_UNITS", static_cast<signed int>(0x2A00)},
    {"POLYGON_OFFSET_FACTOR", static_cast<signed int>(0x8038)},
    {"TEXTURE_BINDING_2D", static_cast<signed int>(0x8069)},
    {"SAMPLE_BUFFERS", static_cast<signed int>(0x80A8)},
    {"SAMPLES", static_cast<signed int>(0x80A9)},
    {"SAMPLE_COVERAGE_VALUE", static_cast<signed int>(0x80AA)},
    {"SAMPLE_COVERAGE_INVERT", static_cast<signed int>(0x80AB)},
    {"NUM_COMPRESSED_TEXTURE_FORMATS", static_cast<signed int>(0x86A2)},
    {"COMPRESSED_TEXTURE_FORMATS", static_cast<signed int>(0x86A3)},
    {"DONT_CARE", static_cast<signed int>(0x1100)},
    {"FASTEST", static_cast<signed int>(0x1101)},
    {"NICEST", static_cast<signed int>(0x1102)},
    {"GENERATE_MIPMAP_HINT", static_cast<signed int>(0x8192)},
    {"BYTE", static_cast<signed int>(0x1400)},
    {"UNSIGNED_BYTE", static_cast<signed int>(0x1401)},
    {"SHORT", static_cast<signed int>(0x1402)},
    {"UNSIGNED_SHORT", static_cast<signed int>(0x1403)},
    {"INT", static_cast<signed int>(0x1404)},
    {"UNSIGNED_INT", static_cast<signed int>(0x1405)},
    {"FLOAT", static_cast<signed int>(0x1406)},
    {"DEPTH_COMPONENT", static_cast<signed int>(0x1902)},
    {"ALPHA", static_cast<signed int>(0x1906)},
    {"RGB", static_cast<signed int>(0x1907)},
    {"RGBA", static_cast<signed int>(0x1908)},
    {"LUMINANCE", static_cast<signed int>(0x1909)},
    {"LUMINANCE_ALPHA", static_cast<signed int>(0x190A)},
    {"UNSIGNED_SHORT_4_4_4_4", static_cast<signed int>(0x8033)},
    {"UNSIGNED_SHORT_5_5_5_1", static_cast<signed int>(0x8034)},
    {"UNSIGNED_SHORT_5_6_5", static_cast<signed int>(0x8363)},
    {"FRAGMENT_SHADER", static_cast<signed int>(0x8B30)},
    {"VERTEX_SHADER", static_cast<signed int>(0x8B31)},
    {"MAX_VERTEX_ATTRIBS", static_cast<signed int>(0x8869)},
    {"MAX_VERTEX_UNIFORM_VECTORS", static_cast<signed int>(0x8DFB)},
    {"MAX_VARYING_VECTORS", static_cast<signed int>(0x8DFC)},
    {"MAX_COMBINED_TEXTURE_IMAGE_UNITS", static_cast<signed int>(0x8B4D)},
    {"MAX_VERTEX_TEXTURE_IMAGE_UNITS", static_cast<signed int>(0x8B4C)},
    {"MAX_TEXTURE_IMAGE_UNITS", static_cast<signed int>(0x8872)},
    {"MAX_FRAGMENT_UNIFORM_VECTORS", static_cast<signed int>(0x8DFD)},
    {"SHADER_TYPE", static_cast<signed int>(0x8B4F)},
    {"DELETE_STATUS", static_cast<signed int>(0x8B80)},
    {"LINK_STATUS", static_cast<signed int>(0x8B82)},
    {"VALIDATE_STATUS", static_cast<signed int>(0x8B83)},
    {"ATTACHED_SHADERS", static_cast<signed int>(0x8B85)},
    {"ACTIVE_UNIFORMS", static_cast<signed int>(0x8B86)},
    {"ACTIVE_ATTRIBUTES", static_cast<signed int>(0x8B89)},
    {"SHADING_LANGUAGE_VERSION", static_cast<signed int>(0x8B8C)},
    {"CURRENT_PROGRAM", static_cast<signed int>(0x8B8D)},
    {"NEVER", static_cast<signed int>(0x0200)},
    {"LESS", static_cast<signed int>(0x0201)},
    {"EQUAL", static_cast<signed int>(0x0202)},
    {"LEQUAL", static_cast<signed int>(0x0203)},
    {"GREATER", static_cast<signed int>(0x0204)},
    {"NOTEQUAL", static_cast<signed int>(0x0205)},
    {"GEQUAL", static_cast<signed int>(0x0206)},
    {"ALWAYS", static_cast<signed int>(0x0207)},
    {"KEEP", static_cast<signed int>(0x1E00)},
    {"REPLACE", static_cast<signed int>(0x1E01)},
    {"INCR", static_cast<signed int>(0x1E02)},
    {"DECR", static_cast<signed int>(0x1E03)},
    {"INVERT", static_cast<signed int>(0x150A)},
    {"INCR_WRAP", static_cast<signed int>(0x8507)},
    {"DECR_WRAP", static_cast<signed int>(0x8508)},
    {"VENDOR", static_cast<signed int>(0x1F00)},
    {"RENDERER", static_cast<signed int>(0x1F01)},
    {"VERSION", static_cast<signed int>(0x1F02)},
    {"NEAREST", static_cast<signed int>(0x2600)},
    {"LINEAR", static_cast<signed int>(0x2601)},
    {"NEAREST_MIPMAP_NEAREST", static_cast<signed int>(0x2700)},
    {"LINEAR_MIPMAP_NEAREST", static_cast<signed int>(0x2701)},
    {"NEAREST_MIPMAP_LINEAR", static_cast<signed int>(0x2702)},
    {"LINEAR_MIPMAP_LINEAR", static_cast<signed int>(0x2703)},
    {"TEXTURE_MAG_FILTER", static_cast<signed int>(0x2800)},
    {"TEXTURE_MIN_FILTER", static_cast<signed int>(0x2801)},
    {"TEXTURE_WRAP_S", static_cast<signed int>(0x2802)},
    {"TEXTURE_WRAP_T", static_cast<signed int>(0x2803)},
    {"TEXTURE", static_cast<signed int>(0x1702)},
    {"TEXTURE_CUBE_MAP", static_cast<signed int>(0x8513)},
    {"TEXTURE_BINDING_CUBE_MAP", static_cast<signed int>(0x8514)},
    {"TEXTURE_CUBE_MAP_POSITIVE_X", static_cast<signed int>(0x8515)},
    {"TEXTURE_CUBE_MAP_NEGATIVE_X", static_cast<signed int>(0x8516)},
    {"TEXTURE_CUBE_MAP_POSITIVE_Y", static_cast<signed int>(0x8517)},
    {"TEXTURE_CUBE_MAP_NEGATIVE_Y", static_cast<signed int>(0x8518)},
    {"TEXTURE_CUBE_MAP_POSITIVE_Z", static_cast<signed int>(0x8519)},
    {"TEXTURE_CUBE_MAP_NEGATIVE_Z", static_cast<signed int>(0x851A)},
    {"MAX_CUBE_MAP_TEXTURE_SIZE", static_cast<signed int>(0x851C)},
    {"TEXTURE0", static_cast<signed int>(0x84C0)},
    {"TEXTURE1", static_cast<signed int>(0x84C1)},
    {"TEXTURE2", static_cast<signed int>(0x84C2)},
    {"TEXTURE3", static_cast<signed int>(0x84C3)},
    {"TEXTURE4", static_cast<signed int>(0x84C4)},
    {"TEXTURE5", static_cast<signed int>(0x84C5)},
    {"TEXTURE6", static_cast<signed int>(0x84C6)},
    {"TEXTURE7", static_cast<signed int>(0x84C7)},
    {"TEXTURE8", static_cast<signed int>(0x84C8)},
    {"TEXTURE9", static_cast<signed int>(0x84C9)},
    {"TEXTURE10", static_cast<signed int>(0x84CA)},
    {"TEXTURE11", static_cast<signed int>(0x84CB)},
    {"TEXTURE12", static_cast<signed int>(0x84CC)},
    {"TEXTURE13", static_cast<signed int>(0x84CD)},
    {"TEXTURE14", static_cast<signed int>(0x84CE)},
    {"TEXTURE15", static_cast<signed int>(0x84CF)},
    {"TEXTURE16", static_cast<signed int>(0x84D0)},
    {"TEXTURE17", static_cast<signed int>(0x84D1)},
    {"TEXTURE18", static_cast<signed int>(0x84D2)},
    {"TEXTURE19", static_cast<signed int>(0x84D3)},
    {"TEXTURE20", static_cast<signed int>(0x84D4)},
    {"TEXTURE21", static_cast<signed int>(0x84D5)},
    {"TEXTURE22", static_cast<signed int>(0x84D6)},
    {"TEXTURE23", static_cast<signed int>(0x84D7)},
    {"TEXTURE24", static_cast<signed int>(0x84D8)},
    {"TEXTURE25", static_cast<signed int>(0x84D9)},
    {"TEXTURE26", static_cast<signed int>(0x84DA)},
    {"TEXTURE27", static_cast<signed int>(0x84DB)},
    {"TEXTURE28", static_cast<signed int>(0x84DC)},
    {"TEXTURE29", static_cast<signed int>(0x84DD)},
    {"TEXTURE30", static_cast<signed int>(0x84DE)},
    {"TEXTURE31", static_cast<signed int>(0x84DF)},
    {"ACTIVE_TEXTURE", static_cast<signed int>(0x84E0)},
    {"REPEAT", static_cast<signed int>(0x2901)},
    {"CLAMP_TO_EDGE", static_cast<signed int>(0x812F)},
    {"MIRRORED_REPEAT", static_cast<signed int>(0x8370)},
    {"FLOAT_VEC2", static_cast<signed int>(0x8B50)},
    {"FLOAT_VEC3", static_cast<signed int>(0x8B51)},
    {"FLOAT_VEC4", static_cast<signed int>(0x8B52)},
    {"INT_VEC2", static_cast<signed int>(0x8B53)},
    {"INT_VEC3", static_cast<signed int>(0x8B54)},
    {"INT_VEC4", static_cast<signed int>(0x8B55)},
    {"BOOL", static_cast<signed int>(0x8B56)},
    {"BOOL_VEC2", static_cast<signed int>(0x8B57)},
    {"BOOL_VEC3", static_cast<signed int>(0x8B58)},
    {"BOOL_VEC4", static_cast<signed int>(0x8B59)},
    {"FLOAT_MAT2", static_cast<signed int>(0x8B5A)},
    {"FLOAT_MAT3", static_cast<signed int>(0x8B5B)},
    {"FLOAT_MAT4", static_cast<signed int>(0x8B5C)},
    {"SAMPLER_2D", static_cast<signed int>(0x8B5E)},
    {"SAMPLER_CUBE", static_cast<signed int>(0x8B60)},
    {"VERTEX_ATTRIB_ARRAY_ENABLED", static_cast<signed int>(0x8622)},
    {"VERTEX_ATTRIB_ARRAY_SIZE", static_cast<signed int>(0x8623)},
    {"VERTEX_ATTRIB_ARRAY_STRIDE", static_cast<signed int>(0x8624)},
    {"VERTEX_ATTRIB_ARRAY_TYPE", static_cast<signed int>(0x8625)},
    {"VERTEX_ATTRIB_ARRAY_NORMALIZED", static_cast<signed int>(0x886A)},
    {"VERTEX_ATTRIB_ARRAY_POINTER", static_cast<signed int>(0x8645)},
    {"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", static_cast<signed int>(0x889F)},
    {"COMPILE_STATUS", static_cast<signed int>(0x8B81)},
    {"SHADER_COMPILER", static_cast<signed int>(0x8DFA)},
    {"LOW_FLOAT", static_cast<signed int>(0x8DF0)},
    {"MEDIUM_FLOAT", static_cast<signed int>(0x8DF1)},
    {"HIGH_FLOAT", static_cast<signed int>(0x8DF2)},
    {"LOW_INT", static_cast<signed int>(0x8DF3)},
    {"MEDIUM_INT", static_cast<signed int>(0x8DF4)},
    {"HIGH_INT", static_cast<signed int>(0x8DF5)},
    {"FRAMEBUFFER", static_cast<signed int>(0x8D40)},
    {"RENDERBUFFER", static_cast<signed int>(0x8D41)},
    {"RGBA4", static_cast<signed int>(0x8056)},
    {"RGB5_A1", static_cast<signed int>(0x8057)},
    {"RGB565", static_cast<signed int>(0x8D62)},
    {"DEPTH_COMPONENT16", static_cast<signed int>(0x81A5)},
    {"STENCIL_INDEX", static_cast<signed int>(0x1901)},
    {"STENCIL_INDEX8", static_cast<signed int>(0x8D48)},
    {"DEPTH_STENCIL", static_cast<signed int>(0x84F9)},
    {"RENDERBUFFER_WIDTH", static_cast<signed int>(0x8D42)},
    {"RENDERBUFFER_HEIGHT", static_cast<signed int>(0x8D43)},
    {"RENDERBUFFER_INTERNAL_FORMAT", static_cast<signed int>(0x8D44)},
    {"RENDERBUFFER_RED_SIZE", static_cast<signed int>(0x8D50)},
    {"RENDERBUFFER_GREEN_SIZE", static_cast<signed int>(0x8D51)},
    {"RENDERBUFFER_BLUE_SIZE", static_cast<signed int>(0x8D52)},
    {"RENDERBUFFER_ALPHA_SIZE", static_cast<signed int>(0x8D53)},
    {"RENDERBUFFER_DEPTH_SIZE", static_cast<signed int>(0x8D54)},
    {"RENDERBUFFER_STENCIL_SIZE", static_cast<signed int>(0x8D55)},
    {"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", static_cast<signed int>(0x8CD0)},
    {"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", static_cast<signed int>(0x8CD1)},
    {"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", static_cast<signed int>(0x8CD2)},
    {"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", static_cast<signed int>(0x8CD3)},
    {"COLOR_ATTACHMENT0", static_cast<signed int>(0x8CE0)},
    {"DEPTH_ATTACHMENT", static_cast<signed int>(0x8D00)},
    {"STENCIL_ATTACHMENT", static_cast<signed int>(0x8D20)},
    {"DEPTH_STENCIL_ATTACHMENT", static_cast<signed int>(0x821A)},
    {"NONE", static_cast<signed int>(0)},
    {"FRAMEBUFFER_COMPLETE", static_cast<signed int>(0x8CD5)},
    {"FRAMEBUFFER_INCOMPLETE_ATTACHMENT", static_cast<signed int>(0x8CD6)},
    {"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", static_cast<signed int>(0x8CD7)},
    {"FRAMEBUFFER_INCOMPLETE_DIMENSIONS", static_cast<signed int>(0x8CD9)},
    {"FRAMEBUFFER_UNSUPPORTED", static_cast<signed int>(0x8CDD)},
    {"FRAMEBUFFER_BINDING", static_cast<signed int>(0x8CA6)},
    {"RENDERBUFFER_BINDING", static_cast<signed int>(0x8CA7)},
    {"MAX_RENDERBUFFER_SIZE", static_cast<signed int>(0x84E8)},
    {"INVALID_FRAMEBUFFER_OPERATION", static_cast<signed int>(0x0506)},
    {"UNPACK_FLIP_Y_WEBGL", static_cast<signed int>(0x9240)},
    {"UNPACK_PREMULTIPLY_ALPHA_WEBGL", static_cast<signed int>(0x9241)},
    {"CONTEXT_LOST_WEBGL", static_cast<signed int>(0x9242)},
    {"UNPACK_COLORSPACE_CONVERSION_WEBGL", static_cast<signed int>(0x9243)},
    {"BROWSER_DEFAULT_WEBGL", static_cast<signed int>(0x9244)},
};

static v8::Persistent<v8::FunctionTemplate> ConfigureV8WebGLRenderingContextTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature = configureTemplate(desc, "WebGLRenderingContext", V8CanvasRenderingContext::GetTemplate(), V8WebGLRenderingContext::internalFieldCount,
        WebGLRenderingContextAttrs, WTF_ARRAY_LENGTH(WebGLRenderingContextAttrs),
        WebGLRenderingContextCallbacks, WTF_ARRAY_LENGTH(WebGLRenderingContextCallbacks));
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    
    batchConfigureConstants(desc, proto, WebGLRenderingContextConsts, WTF_ARRAY_LENGTH(WebGLRenderingContextConsts));

    // Custom toString template
    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

v8::Persistent<v8::FunctionTemplate> V8WebGLRenderingContext::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Persistent<v8::FunctionTemplate> V8WebGLRenderingContext::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8WebGLRenderingContextTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

bool V8WebGLRenderingContext::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}


v8::Handle<v8::Object> V8WebGLRenderingContext::wrapSlow(WebGLRenderingContext* impl)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl);
    if (wrapper.IsEmpty())
        return wrapper;

    impl->ref();
    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    getDOMObjectMap().set(impl, wrapperHandle);
    return wrapper;
}

void V8WebGLRenderingContext::derefObject(void* object)
{
    static_cast<WebGLRenderingContext*>(object)->deref();
}

} // namespace WebCore

#endif // ENABLE(WEBGL)
