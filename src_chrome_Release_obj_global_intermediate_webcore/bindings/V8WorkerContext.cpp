/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/

#include "config.h"
#include "V8WorkerContext.h"

#if ENABLE(WORKERS)

#include "EventListener.h"
#include "ExceptionCode.h"
#include "RuntimeEnabledFeatures.h"
#include "V8AbstractEventListener.h"
#include "V8ArrayBuffer.h"
#include "V8Binding.h"
#include "V8BindingMacros.h"
#include "V8BindingState.h"
#include "V8DOMFileSystemSync.h"
#include "V8DOMURL.h"
#include "V8DOMWrapper.h"
#include "V8DataView.h"
#include "V8Database.h"
#include "V8DatabaseCallback.h"
#include "V8DatabaseSync.h"
#include "V8EntryCallback.h"
#include "V8EntrySync.h"
#include "V8ErrorCallback.h"
#include "V8Event.h"
#include "V8EventListenerList.h"
#include "V8EventSource.h"
#include "V8FileError.h"
#include "V8FileException.h"
#include "V8FileReader.h"
#include "V8FileReaderSync.h"
#include "V8FileSystemCallback.h"
#include "V8Float32Array.h"
#include "V8Float64Array.h"
#include "V8Int16Array.h"
#include "V8Int32Array.h"
#include "V8Int8Array.h"
#include "V8IsolatedContext.h"
#include "V8MessageChannel.h"
#include "V8MessageEvent.h"
#include "V8NotificationCenter.h"
#include "V8Proxy.h"
#include "V8Uint16Array.h"
#include "V8Uint32Array.h"
#include "V8Uint8Array.h"
#include "V8WebKitBlobBuilder.h"
#include "V8WebKitFlags.h"
#include "V8WebSocket.h"
#include "V8WorkerContextErrorHandler.h"
#include "V8WorkerLocation.h"
#include "V8WorkerNavigator.h"
#include "V8XMLHttpRequest.h"
#include <wtf/GetPtr.h>
#include <wtf/RefCounted.h>
#include <wtf/RefPtr.h>

namespace WebCore {

WrapperTypeInfo V8WorkerContext::info = { V8WorkerContext::GetTemplate, V8WorkerContext::derefObject, 0, 0 };

namespace WorkerContextInternal {

template <typename T> void V8_USE(T) { }

static v8::Handle<v8::Value> selfAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.self._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    return toV8(imp->self());
}

static v8::Handle<v8::Value> locationAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.location._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<WorkerLocation> result = imp->location();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "location", wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> onerrorAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.onerror._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    return imp->onerror() ? v8::Handle<v8::Value>(static_cast<V8AbstractEventListener*>(imp->onerror())->getListenerObject(imp->scriptExecutionContext())) : v8::Handle<v8::Value>(v8::Null());
}

static void onerrorAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.onerror._set");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    transferHiddenDependency(info.Holder(), imp->onerror(), value, V8WorkerContext::eventListenerCacheIndex);
    imp->setOnerror(V8EventListenerList::findOrCreateWrapper<V8WorkerContextErrorHandler>(value, true));
    return;
}

static v8::Handle<v8::Value> navigatorAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.navigator._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<WorkerNavigator> result = imp->navigator();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "navigator", wrapper);
    }
    return wrapper;
}

static v8::Handle<v8::Value> webkitNotificationsAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.webkitNotifications._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<NotificationCenter> result = imp->webkitNotifications();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "webkitNotifications", wrapper);
    }
    return wrapper;
}

#if ENABLE(BLOB)

static v8::Handle<v8::Value> webkitURLAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.webkitURL._get");
    WorkerContext* imp = V8WorkerContext::toNative(info.Holder());
    RefPtr<DOMURL> result = imp->webkitURL();
    v8::Handle<v8::Value> wrapper = result.get() ? getDOMObjectMap().get(result.get()) : v8::Handle<v8::Value>();
    if (wrapper.IsEmpty()) {
        wrapper = toV8(result.get());
        if (!wrapper.IsEmpty())
            V8DOMWrapper::setNamedHiddenReference(info.Holder(), "webkitURL", wrapper);
    }
    return wrapper;
}

#endif // ENABLE(BLOB)

static v8::Handle<v8::Value> WorkerContextConstructorGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info)
{
    INC_STATS("DOM.WorkerContext.constructors._get");
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal() || data->IsNumber());
    WrapperTypeInfo* type = WrapperTypeInfo::unwrap(data);
    return V8DOMWrapper::getConstructor(type, V8WorkerContext::toNative(info.Holder()));
}

static v8::Handle<v8::Value> closeCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.close");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    imp->close();
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> openDatabaseCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.openDatabase");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined));
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, version, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined));
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, displayName, MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined));
    EXCEPTION_BLOCK(unsigned, estimatedSize, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    RefPtr<DatabaseCallback> creationCallback;
    if (args.Length() > 4 && !args[4]->IsNull() && !args[4]->IsUndefined()) {
        if (!args[4]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        creationCallback = V8DatabaseCallback::create(args[4], getScriptExecutionContext());
    }
    RefPtr<Database> result = imp->openDatabase(name, version, displayName, estimatedSize, creationCallback, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> openDatabaseSyncCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.openDatabaseSync");
    if (args.Length() < 4)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, name, MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined));
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, version, MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined));
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, displayName, MAYBE_MISSING_PARAMETER(args, 2, MissingIsUndefined));
    EXCEPTION_BLOCK(unsigned, estimatedSize, toUInt32(MAYBE_MISSING_PARAMETER(args, 3, MissingIsUndefined)));
    RefPtr<DatabaseCallback> creationCallback;
    if (args.Length() > 4 && !args[4]->IsNull() && !args[4]->IsUndefined()) {
        if (!args[4]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        creationCallback = V8DatabaseCallback::create(args[4], getScriptExecutionContext());
    }
    RefPtr<DatabaseSync> result = imp->openDatabaseSync(name, version, displayName, estimatedSize, creationCallback, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearTimeoutCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.clearTimeout");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, handle, toInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->clearTimeout(handle);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> clearIntervalCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.clearInterval");
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, handle, toInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    imp->clearInterval(handle);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> addEventListenerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.addEventListener()");
    RefPtr<EventListener> listener = V8DOMWrapper::getEventListener(args[1], false, ListenerFindOrCreate);
    if (listener) {
        V8WorkerContext::toNative(args.Holder())->addEventListener(v8ValueToAtomicWebCoreString(args[0]), listener, args[2]->BooleanValue());
        createHiddenDependency(args.Holder(), args[1], V8WorkerContext::eventListenerCacheIndex);
    }
    return v8::Undefined();
}

static v8::Handle<v8::Value> removeEventListenerCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.removeEventListener()");
    RefPtr<EventListener> listener = V8DOMWrapper::getEventListener(args[1], false, ListenerFindOnly);
    if (listener) {
        V8WorkerContext::toNative(args.Holder())->removeEventListener(v8ValueToAtomicWebCoreString(args[0]), listener.get(), args[2]->BooleanValue());
        removeHiddenDependency(args.Holder(), args[1], V8WorkerContext::eventListenerCacheIndex);
    }
    return v8::Undefined();
}

static v8::Handle<v8::Value> dispatchEventCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.dispatchEvent");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(Event*, evt, V8Event::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)) ? V8Event::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined))) : 0);
    bool result = imp->dispatchEvent(evt, ec);
    if (UNLIKELY(ec))
        goto fail;
    return v8Boolean(result);
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> webkitRequestFileSystemCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.webkitRequestFileSystem");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    EXCEPTION_BLOCK(int, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(long long, size, toInt64(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    RefPtr<FileSystemCallback> successCallback;
    if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {
        if (!args[2]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        successCallback = V8FileSystemCallback::create(args[2], getScriptExecutionContext());
    }
    RefPtr<ErrorCallback> errorCallback;
    if (args.Length() > 3 && !args[3]->IsNull() && !args[3]->IsUndefined()) {
        if (!args[3]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        errorCallback = V8ErrorCallback::create(args[3], getScriptExecutionContext());
    }
    imp->webkitRequestFileSystem(type, size, successCallback, errorCallback);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> webkitRequestFileSystemSyncCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.webkitRequestFileSystemSync");
    if (args.Length() < 2)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    EXCEPTION_BLOCK(int, type, toUInt32(MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined)));
    EXCEPTION_BLOCK(long long, size, toInt64(MAYBE_MISSING_PARAMETER(args, 1, MissingIsUndefined)));
    RefPtr<DOMFileSystemSync> result = imp->webkitRequestFileSystemSync(type, size, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> webkitResolveLocalFileSystemURLCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.webkitResolveLocalFileSystemURL");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, url, MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined));
    RefPtr<EntryCallback> successCallback;
    if (args.Length() > 1 && !args[1]->IsNull() && !args[1]->IsUndefined()) {
        if (!args[1]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        successCallback = V8EntryCallback::create(args[1], getScriptExecutionContext());
    }
    RefPtr<ErrorCallback> errorCallback;
    if (args.Length() > 2 && !args[2]->IsNull() && !args[2]->IsUndefined()) {
        if (!args[2]->IsObject())
            return throwError(TYPE_MISMATCH_ERR);
        errorCallback = V8ErrorCallback::create(args[2], getScriptExecutionContext());
    }
    imp->webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    return v8::Handle<v8::Value>();
}

static v8::Handle<v8::Value> webkitResolveLocalFileSystemSyncURLCallback(const v8::Arguments& args)
{
    INC_STATS("DOM.WorkerContext.webkitResolveLocalFileSystemSyncURL");
    if (args.Length() < 1)
        return throwError("Not enough arguments", V8Proxy::TypeError);
    WorkerContext* imp = V8WorkerContext::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    STRING_TO_V8PARAMETER_EXCEPTION_BLOCK(V8Parameter<>, url, MAYBE_MISSING_PARAMETER(args, 0, MissingIsUndefined));
    RefPtr<EntrySync> result = imp->webkitResolveLocalFileSystemSyncURL(url, ec);
    if (UNLIKELY(ec))
        goto fail;
    return toV8(result.release());
    }
    fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
}

} // namespace WorkerContextInternal

static const BatchedAttribute WorkerContextAttrs[] = {
    // Attribute 'self' (Type: 'attribute' ExtAttr: 'Replaceable')
    {"self", WorkerContextInternal::selfAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None | v8::ReadOnly), 0 /* on instance */},
    // Attribute 'location' (Type: 'attribute' ExtAttr: 'Replaceable')
    {"location", WorkerContextInternal::locationAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None | v8::ReadOnly), 0 /* on instance */},
    // Attribute 'onerror' (Type: 'attribute' ExtAttr: '')
    {"onerror", WorkerContextInternal::onerrorAttrGetter, WorkerContextInternal::onerrorAttrSetter, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
    // Attribute 'navigator' (Type: 'attribute' ExtAttr: 'Replaceable')
    {"navigator", WorkerContextInternal::navigatorAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None | v8::ReadOnly), 0 /* on instance */},
    // Attribute 'MessageEvent' (Type: 'attribute' ExtAttr: '')
    {"MessageEvent", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8MessageEvent::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'WorkerLocation' (Type: 'attribute' ExtAttr: '')
    {"WorkerLocation", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8WorkerLocation::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'MessageChannel' (Type: 'attribute' ExtAttr: 'JSCCustomGetter')
    {"MessageChannel", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8MessageChannel::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'EventSource' (Type: 'attribute' ExtAttr: 'JSCCustomGetter')
    {"EventSource", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8EventSource::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'XMLHttpRequest' (Type: 'attribute' ExtAttr: 'JSCCustomGetter')
    {"XMLHttpRequest", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8XMLHttpRequest::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'WebKitBlobBuilder' (Type: 'attribute' ExtAttr: '')
    {"WebKitBlobBuilder", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8WebKitBlobBuilder::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'FileReader' (Type: 'attribute' ExtAttr: '')
    {"FileReader", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8FileReader::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'FileReaderSync' (Type: 'attribute' ExtAttr: '')
    {"FileReaderSync", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8FileReaderSync::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
#if ENABLE(BLOB)
    // Attribute 'webkitURL' (Type: 'readonly attribute' ExtAttr: 'Conditional')
    {"webkitURL", WorkerContextInternal::webkitURLAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */},
#endif // ENABLE(BLOB)
    // Attribute 'ArrayBuffer' (Type: 'attribute' ExtAttr: '')
    {"ArrayBuffer", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8ArrayBuffer::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Int8Array' (Type: 'attribute' ExtAttr: '')
    {"Int8Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Int8Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Uint8Array' (Type: 'attribute' ExtAttr: '')
    {"Uint8Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Uint8Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Int16Array' (Type: 'attribute' ExtAttr: '')
    {"Int16Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Int16Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Uint16Array' (Type: 'attribute' ExtAttr: '')
    {"Uint16Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Uint16Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Int32Array' (Type: 'attribute' ExtAttr: '')
    {"Int32Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Int32Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Uint32Array' (Type: 'attribute' ExtAttr: '')
    {"Uint32Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Uint32Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Float32Array' (Type: 'attribute' ExtAttr: '')
    {"Float32Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Float32Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'Float64Array' (Type: 'attribute' ExtAttr: '')
    {"Float64Array", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8Float64Array::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
    // Attribute 'DataView' (Type: 'attribute' ExtAttr: '')
    {"DataView", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8DataView::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */},
};

static const BatchedCallback WorkerContextCallbacks[] = {
    {"close", WorkerContextInternal::closeCallback},
    {"importScripts", V8WorkerContext::importScriptsCallback},
    {"setTimeout", V8WorkerContext::setTimeoutCallback},
    {"clearTimeout", WorkerContextInternal::clearTimeoutCallback},
    {"setInterval", V8WorkerContext::setIntervalCallback},
    {"clearInterval", WorkerContextInternal::clearIntervalCallback},
    {"addEventListener", WorkerContextInternal::addEventListenerCallback},
    {"removeEventListener", WorkerContextInternal::removeEventListenerCallback},
};

static const BatchedConstant WorkerContextConsts[] = {
    {"TEMPORARY", static_cast<signed int>(0)},
    {"PERSISTENT", static_cast<signed int>(1)},
};


COMPILE_ASSERT(0 == WorkerContext::TEMPORARY, WorkerContextEnumTEMPORARYIsWrongUseDontCheckEnums);
COMPILE_ASSERT(1 == WorkerContext::PERSISTENT, WorkerContextEnumPERSISTENTIsWrongUseDontCheckEnums);

static v8::Persistent<v8::FunctionTemplate> ConfigureV8WorkerContextTemplate(v8::Persistent<v8::FunctionTemplate> desc)
{
    desc->ReadOnlyPrototype();

    v8::Local<v8::Signature> defaultSignature = configureTemplate(desc, "WorkerContext", v8::Persistent<v8::FunctionTemplate>(), V8WorkerContext::internalFieldCount,
        WorkerContextAttrs, WTF_ARRAY_LENGTH(WorkerContextAttrs),
        WorkerContextCallbacks, WTF_ARRAY_LENGTH(WorkerContextCallbacks));
    v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
    v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
    
    if (RuntimeEnabledFeatures::webkitNotificationsEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'webkitNotifications' (Type: 'readonly attribute' ExtAttr: 'EnabledAtRuntime')
        {"webkitNotifications", WorkerContextInternal::webkitNotificationsAttrGetter, 0, 0 /* no data */, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::None), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::webSocketEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'WebSocket' (Type: 'attribute' ExtAttr: 'JSCCustomGetter EnabledAtRuntime')
        {"WebSocket", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8WebSocket::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::fileSystemEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'WebKitFlags' (Type: 'attribute' ExtAttr: 'EnabledAtRuntime')
        {"WebKitFlags", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8WebKitFlags::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::fileSystemEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'FileError' (Type: 'attribute' ExtAttr: 'EnabledAtRuntime')
        {"FileError", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8FileError::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::fileSystemEnabled()) {
        static const BatchedAttribute attrData =\
        // Attribute 'FileException' (Type: 'attribute' ExtAttr: 'EnabledAtRuntime')
        {"FileException", WorkerContextInternal::WorkerContextConstructorGetter, 0, &V8FileException::info, static_cast<v8::AccessControl>(v8::DEFAULT), static_cast<v8::PropertyAttribute>(v8::ReadOnly), 0 /* on instance */};
        configureAttribute(instance, proto, attrData);
    }
    if (RuntimeEnabledFeatures::openDatabaseEnabled())
        proto->Set(v8::String::New("openDatabase"), v8::FunctionTemplate::New(WorkerContextInternal::openDatabaseCallback, v8::Handle<v8::Value>(), defaultSignature));
    if (RuntimeEnabledFeatures::openDatabaseSyncEnabled())
        proto->Set(v8::String::New("openDatabaseSync"), v8::FunctionTemplate::New(WorkerContextInternal::openDatabaseSyncCallback, v8::Handle<v8::Value>(), defaultSignature));

    // Custom Signature 'dispatchEvent'
    const int dispatchEventArgc = 1;
    v8::Handle<v8::FunctionTemplate> dispatchEventArgv[dispatchEventArgc] = { V8Event::GetRawTemplate() };
    v8::Handle<v8::Signature> dispatchEventSignature = v8::Signature::New(desc, dispatchEventArgc, dispatchEventArgv);
    proto->Set(v8::String::New("dispatchEvent"), v8::FunctionTemplate::New(WorkerContextInternal::dispatchEventCallback, v8::Handle<v8::Value>(), dispatchEventSignature));
    if (RuntimeEnabledFeatures::fileSystemEnabled())
        proto->Set(v8::String::New("webkitRequestFileSystem"), v8::FunctionTemplate::New(WorkerContextInternal::webkitRequestFileSystemCallback, v8::Handle<v8::Value>(), defaultSignature));
    if (RuntimeEnabledFeatures::fileSystemEnabled())
        proto->Set(v8::String::New("webkitRequestFileSystemSync"), v8::FunctionTemplate::New(WorkerContextInternal::webkitRequestFileSystemSyncCallback, v8::Handle<v8::Value>(), defaultSignature));
    if (RuntimeEnabledFeatures::fileSystemEnabled())
        proto->Set(v8::String::New("webkitResolveLocalFileSystemURL"), v8::FunctionTemplate::New(WorkerContextInternal::webkitResolveLocalFileSystemURLCallback, v8::Handle<v8::Value>(), defaultSignature));
    if (RuntimeEnabledFeatures::fileSystemEnabled())
        proto->Set(v8::String::New("webkitResolveLocalFileSystemSyncURL"), v8::FunctionTemplate::New(WorkerContextInternal::webkitResolveLocalFileSystemSyncURLCallback, v8::Handle<v8::Value>(), defaultSignature));
    batchConfigureConstants(desc, proto, WorkerContextConsts, WTF_ARRAY_LENGTH(WorkerContextConsts));

    // Custom toString template
    desc->Set(getToStringName(), getToStringTemplate());
    return desc;
}

v8::Persistent<v8::FunctionTemplate> V8WorkerContext::GetRawTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->rawTemplateMap().find(&info);
    if (result != data->rawTemplateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ = createRawTemplate();
    data->rawTemplateMap().add(&info, templ);
    return templ;
}

v8::Persistent<v8::FunctionTemplate> V8WorkerContext::GetTemplate()
{
    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();
    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);
    if (result != data->templateMap().end())
        return result->second;

    v8::HandleScope handleScope;
    v8::Persistent<v8::FunctionTemplate> templ =
        ConfigureV8WorkerContextTemplate(GetRawTemplate());
    data->templateMap().add(&info, templ);
    return templ;
}

bool V8WorkerContext::HasInstance(v8::Handle<v8::Value> value)
{
    return GetRawTemplate()->HasInstance(value);
}


v8::Handle<v8::Object> V8WorkerContext::wrapSlow(WorkerContext* impl)
{
    v8::Handle<v8::Object> wrapper;
    V8Proxy* proxy = 0;
    wrapper = V8DOMWrapper::instantiateV8Object(proxy, &info, impl);
    if (wrapper.IsEmpty())
        return wrapper;

    impl->ref();
    v8::Persistent<v8::Object> wrapperHandle = v8::Persistent<v8::Object>::New(wrapper);

    if (!hasDependentLifetime)
        wrapperHandle.MarkIndependent();
    getDOMObjectMap().set(impl, wrapperHandle);
    return wrapper;
}

void V8WorkerContext::derefObject(void* object)
{
    static_cast<WorkerContext*>(object)->deref();
}

} // namespace WebCore

#endif // ENABLE(WORKERS)
